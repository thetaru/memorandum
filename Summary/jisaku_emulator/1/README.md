# 1.1 C言語から機械語へ
CPUは機械語の列だけを解釈できます。  
例えば、以下のC言語のソースコード
```c
void func(void) {
  int val = 0;
  val++;
}
```
を機械語に変換すると
```
55 89 e5 83 ec 10 c7 45 fc 00 00 00 00 ff 45 fc c9 c3
```
(16進数表示ですが)0と1の列に変換されたことがわかります。  
CPUはこのような0と1だけからなる機械語しか解釈・実行できません。  

# 1.2 機械語とアセンブリ言語
機械語は人間にとってわかりずらいので、比較的読みやすいアセンブリ言語が作られました。  
上で挙げたソースコードをアセンブラ言語に変換し機械語と対応させたものを示します。
```asm
push ebp                    ; 55
mov ebp, esp                ; 89 e5
sub esp, byte +0x10         ; 83 ec 10
mov dword [ebp-0x4], 0x0    ; c7 45 fc 00 00 00 00
int dword [ebp-0x4]         ; ff 45 fc
leave                       ; c9
ret                         ; c3
```
機械語とアセンブリ言語は(例外を除き)一対一に対応しますが、機械語とC言語に一対一に対応しません。  
※ C言語にはシュガーシンタックスがあるので当たり前ですよね？  
  
# 1.3 機械語に飛び込む
機械語をアセンブリ言語に変換することを逆アセンブルといいます。  
まず、C言語ファイルcasm-c-sample.cを32bitバイナリcasm-c-sample.binにコンパイルします。
```
# gcc -Wl,--entry=func,--oformat=binary -nostdlib -fno-asynchronous-unwind-tables -m32 -o casm-c-sample.bin casm-c-sample.c
```
次に、32bitバイナリcasm-c-sample.binを逆アセンブルし、アセンブリ言語表示します。  
※ ndisasmはnasmをインストールすると入ります。
```
# ndisasm -b 32 casm-c-sample.bin
```
```
00000000  55                push ebp
00000001  89E5              mov ebp,esp
00000003  83EC10            sub esp,byte +0x10
00000006  C745FC00000000    mov dword [ebp-0x4],0x0
0000000D  8345FC01          add dword [ebp-0x4],byte +0x1
00000011  90                nop
00000012  C9                leave
00000013  C3                ret
```
最後に、C言語プログラムをデバッグ情報付きでコンパイルし、出力されたオブジェクトファイルを見てみます。
```
# gcc -c -g -o casm-c-sample.o casm-c-sample.c
# objdump -d -S -M intel casm-c-sample.o
```
```
casm-c-sample.o:     ファイル形式 elf64-x86-64


セクション .text の逆アセンブル:

0000000000000000 <func>:
void func(void) {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int val = 0;
   4:   c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
  val++;
   b:   83 45 fc 01             add    DWORD PTR [rbp-0x4],0x1
}
   f:   90                      nop
  10:   5d                      pop    rbp
  11:   c3                      ret
```
※ NSAMの書式や使用しているレジスタが異なるが気にしないことにする

# 1.4 アセンブリ言語を少し詳しく
アセンブリ言語の命令は1行につき1命令を書きます。  
#### Syntax
```
オペコード    オペランド1 オペランド2
```
オペランドとオペコードを合わせたものをニーモニックといいます。

# 1.5 基本のmov命令
#### Syntax
```
mov 移動先, 移動元
```
データが移動元から移動先へ移動(正確にはコピー)します。  
一度に移動できるデータは4バイトか2バイトか1バイトです。

## 例1
```
mov ebp, esp
```
この場合は、コピー元espからコピー先ebpへ値をコピーします。(つまり、ebpの値はespの持つ値に上書きされる。)  
※ espやebpはレジスタと呼ばれる記憶領域で、CPUに内蔵されており、任意の32bitの値を記憶できます。  
  
### espとは何か?
espはスタックポインタと呼ばれ、常にスタックの最新の読み書き位置を保持しています。  
  
スタックとは、(ざっくり説明すると)C言語でいうところのローカル変数が置かれるデータ領域です。  
スタックのデータ領域は広いため、変数が必要になったときに毎度探索するのは現実的ではありません。  
そこで、スタックのデータ領域の中で最近に読み書きされたアドレス(スタックポインタ)を保持することによって探索する手間を省いています。

## 例2
