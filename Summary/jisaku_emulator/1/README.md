# 1.1 C言語から機械語へ
CPUは機械語の列だけを解釈できます。  
例えば、以下のC言語のソースコード
```c
void func(void) {
  int val = 0;
  val++;
}
```
を機械語に変換すると
```
55 89 e5 83 ec 10 c7 45 fc 00 00 00 00 ff 45 fc c9 c3
```
(16進数表示ですが)0と1の列に変換されたことがわかります。  
CPUはこのような0と1だけからなる機械語しか解釈・実行できません。  

# 1.2 機械語とアセンブリ言語
機械語は人間にとってわかりずらいので、比較的読みやすいアセンブリ言語が作られました。  
上で挙げたソースコードをアセンブラ言語に変換し機械語と対応させたものを示します。
```asm
push ebp                    ; 55
mov ebp, esp                ; 89 e5
sub esp, byte +0x10         ; 83 ec 10
mov dword [ebp-0x4], 0x0    ; c7 45 fc 00 00 00 00
int dword [ebp-0x4]         ; ff 45 fc
leave                       ; c9
ret                         ; c3
```
機械語とアセンブリ言語は(例外を除き)一対一に対応しますが、機械語とC言語に一対一に対応しません。  
※ C言語には(に限らず)シュガーシンタックスがあるので当たり前？  
  
# 1.3 機械語に飛び込む
機械語をアセンブリ言語に変換することを逆アセンブルといいます。  
まず、C言語ファイルcasm-c-sample.cを32bitバイナリcasm-c-sample.binにコンパイルします。
```
# gcc -Wl,--entry=func,--oformat=binary -nostdlib -fno-asynchronous-unwind-tables -m32 -o casm-c-sample.bin casm-c-sample.c
```
次に、32bitバイナリcasm-c-sample.binを逆アセンブルし、アセンブリ言語表示します。  
※ ndisasmはnasmをインストールすると入ります。
```
# ndisasm -b 32 casm-c-sample.bin
```
```
00000000  55                push ebp
00000001  89E5              mov ebp,esp
00000003  83EC10            sub esp,byte +0x10
00000006  C745FC00000000    mov dword [ebp-0x4],0x0
0000000D  8345FC01          add dword [ebp-0x4],byte +0x1
00000011  90                nop
00000012  C9                leave
00000013  C3                ret
```
最後に、C言語プログラムをデバッグ情報付きでコンパイルし、出力されたオブジェクトファイルを見てみます。
```
# gcc -c -g -o casm-c-sample.o casm-c-sample.c
# objdump -d -S -M intel casm-c-sample.o
```
```
casm-c-sample.o:     ファイル形式 elf64-x86-64


セクション .text の逆アセンブル:

0000000000000000 <func>:
void func(void) {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int val = 0;
   4:   c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
  val++;
   b:   83 45 fc 01             add    DWORD PTR [rbp-0x4],0x1
}
   f:   90                      nop
  10:   5d                      pop    rbp
  11:   c3                      ret
```
prefixが`r`であれば64bitレジスタ、`e`であれば32bitレジスタ、prefixがついていなければ16bitレジスタとなります。

# 1.4 アセンブリ言語を少し詳しく
アセンブリ言語の命令は1行につき1命令を書きます。  
#### Syntax
```
オペコード    オペランド1 オペランド2
```
オペランドとオペコードを合わせたものをニーモニックといいます。

# 1.5 基本のmov命令
#### Syntax
```
mov 移動先, 移動元
```
データが移動元から移動先へ移動(正確にはコピー)します。  
一度に移動できるデータは4バイトか2バイトか1バイトです。

## 例1
```
mov ebp, esp
```
この場合は、コピー元espからコピー先ebpへ値をコピーします。(つまり、ebpの値はespの持つ値に上書きされる。)  
※ espやebpはレジスタと呼ばれる記憶領域で、CPUに内蔵されており、任意の32bitの値を記憶できます。  
  
### espとは何か?
espはスタックポインタと呼ばれ、常にスタックの最新の読み書き位置を保持しています。  
  
スタックとは、(ざっくり説明すると)C言語でいうところのローカル変数が置かれるデータ領域です。  
CPUはプログラム実行時にデータの一時的な退避が必要になると、スタックのどこかのアドレスにデータを書き込みます。  
このどこかのアドレス(つまり、次に書き込みに行くべきアドレス)を指定するのがスタックポインタの役割です。
  
このような役割から、espの値はすぐに変更されてしまうので、その瞬間のスタックポインタを後で使うために他のレジスタにコピーしておくというわけです。
## 例2
```
mov dword [ebp-0x4], 0x0
```
この場合は、数値0x0をアドレスebp-4から始まる32bitの領域(dword=32bit)へコピーします。  
また、1つのアドレスごとに8bit分のデータを格納できるので、8bit×4=32bit分の領域(ebp-4 ~ ebp-1)を使用しますよと宣言しています。  
※1 ebp自身のアドレスには既にespからコピーした値が格納させているので(この時点では)上書きしてはいけません。  
※2 以上より、宣言するアドレスの領域(bit)とデータ型の大きさ(bit)は一致させる必要がある(？)
### dword [ebp-0x4]とは何か?
dword [ebp-0x4]の構成要素の意味はそれぞれ以下のようになります。
- コピー先のメモリ番地を計算する部分: ebp-0x4
- メモリのアドレスだと宣言する部分: []
- 領域の大きさを指定する部分: dword

# 1.6 インクリメント専用のinc命令
#### Syntax
```
inc インクリメント対象
```
### 機械語の構造
|プレフィックス|オペコード|ModR/M|SIB|ディスプレースメント|イミディメイト|
|:---|:---|:---|:---|:---|:---|
