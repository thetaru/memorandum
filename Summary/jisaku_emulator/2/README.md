# 2.1 レジスタ
レジスタは、CPUに組み込まれている作業用領域のことです。  
アセンブリ言語の命令で何らかのデータを扱う際、ほとんどの場合にレジスタを指定できます。  
※ 命令によっては、暗黙的に特定のレジスタがデータの読み込み元・書き込み先として固定されている場合があります。  
  
アセンブリ言語ではレジスタを直接扱いますが、C言語からレジスタを扱うことはできません。  
C言語では変数という名前で抽象化され、Cコンパイラが必要に応じてレジスタを操作するアセンブリ言語命令を出力します。  
  
# 2.2 メモリ
メモリは、CPUの外側に接続されている部品です。  
データを記憶するという機能はレジスタと同じですが、レジスタより容量も大きいです。(eaxレジスタが4バイトなのに対し、数GBのメモリが搭載されています)
```
+--------------------------------------+                                 +--------------+
|                  CPU                 |                                 |              |
|    +---------+        +---------+    |             Address             |              |
|    |   eax   |        |   esp   |    | ------------------------------> |              |
|    +---------+        +---------+    |                                 |              |
|    +---------+        +---------+    |                                 |              |
|    |   ecx   |        |   ebp   |    |                                 |              |
|    +---------+        +---------+    |                                 |    Memory    |
|    +---------+        +---------+    |                                 |              |
|    |   edx   |        |   esi   |    |                                 |              |
|    +---------+        +---------+    |                                 |              |
|    +---------+        +---------+    |               data              |              |
|    |   ebx   |        |   edi   |    | <-----------------------------> |              |
|    +---------+        +---------+    |                                 |              |
+--------------------------------------+                                 +--------------+
     レジスタはCPU内部にあります。                                      メモリはCPU外部にあります。
           SRAMなので速いです。                                           DRAMなので遅いです。
```
CPUは大きな記憶領域(メモリ)に対し、メモリの先頭から1バイトずつ振られた連番を使ってアクセスします。  

## 例1
メモリの0x7c00番地から0x7c03番地の4バイトのデータを0x7a00番地から0x7a03番地の領域にコピーするには
```asm
mov eax, [0x7c00]
mov [0x7a00], eax
```
また、こんな書き方もできます。
```asm
mov ebx, 0x7a00
mov eax, [ebx+0x200]
mov [ebx], eax
```
0x7a00と0x7c00がメモリ番地であることをアセンブラに伝えるには、それぞれ`[]`で囲みます。

## 例2
以下のソースコードをアセンブルするとlea命令という命令があることがわかります。  
この命令は、指定されたメモリ番地を計算し、その結果の番地をレジスタに書き込みます。
```c
void func(void)
{
  int val;
  int *ptr = &val;
  *ptr = 41;
}
```
```asm
                        ; void func(void) {
push ebp
mov ebp,esp
sub esp,16

                        ; int val;
                        ; int *ptr = &val;
lea eax,[ebp-0x8]       ; 変数val([ebp-8])の番地がeaxに格納されます
mov [ebp-0x4],eax       ; eaxの値が変数ptr([ebp-4])に格納されます

                        ; *ptr = 41;
mov eax,[ebp-0x4]       ; 変数ptrの値をeaxに読み出してから、
mov dword [eax],0x29    ; eaxの値で示される4バイトのメモリ領域に41を書き込みます

                        ; }
leave
ret
```
レジスタはeax、ebpのように名前で指定するのに対し、メモリは[ebp-4]のように番地を使って指定します。  
アセンブリ言語ではレジスタは名前で、メモリは番地でその場所を表します。

# 2.3 初めてのエミュレータ
データの演算装置(加算器や論理演算器など)は、エミュレータが動くパソコンのCPUの演算装置をそのまま使います。  
※ つまり、加算`+`や論理積`&`は流用します  
  
まず、エミュレータ本体を表す構造体Emulatorを定義します。  
構造体Emulatorは基本型変数、配列変数、ポインタ変数という複数種類の変数を含んでいます。  
この中でeipやeflagsはCPUの特殊なレジスタを表します。  
※ eipは、実行中の機械語が置かれてあるメモリ番地を記憶するレジスタです
```c
typedef struct {
  /* 汎用レジスタ */
  uint32_t registers[REGISTERS_COUNT];
  
  /* EFLAGSレジスタ */
  uint32_t eflags;
  
  /* メモリ(バイト列) */
  uint8_t* memory;
  
  /* プログラムカウンタ */
  uint32_t eip;
} Emulator;
```
次に、create_emuでエミュレータ構造隊を生成して初期化し、機械語ファイルを開き、freadでemy->memoryに読み取ります。  
※ コマンドライン引数に機械語プログラムが格納されたファイルを指定する仕様としました。
```c
/* エミュレータを作成する */
Emulator* create_emu(size_t size, uint32_t eip, uint32_t esp)
{
    Emulator* emu = malloc(sizeof(Emulator));
    emu->memory = malloc(size);

    /* 汎用レジスタの初期値をすべて0にする */
    memset(emu->registers, 0, sizeof(emu->registers));
    
    /* レジスタの初期値を指定されたものにする */
    emu->eip = eip;
    emu->registers[ESP] = esp;

    return emu;
}

/* エミュレータを破棄する */
void destroy_emu(Emulator* emu)
{
    free(emu->memory);
    free(emu);
}

int main(int argc, char *argv[])
{
    FILE *binary;
    Emulator* emu;

    if (argc != 2) {
        printf("usage: px86 filename\n");
        return 1;
    }

    /* EIPが0、ESPが0x7C00の状態のエミュレータを生成する */
    emu = create_emu(MEMORY_SIZE, 0x0000, 0x7c00);

    binary = fopen(argv[1], "rb");
    if (binary == NULL) {
        printf("%sファイルが開けません\n", argv[1]);
        return 1;
    }

    /* 機械語ファイルを読み込む(最大512バイト) */
    fread(emu->memory, 1, 0x200, binary);
    fclose(binary);

    destroy_emu(emu);
    return 0;
}
```
次はエミュレータの核心部、機械語を実行する部分を作っていきます。  
プログラムの基本方針として、emy->memory[emu->eip]から1バイト(つまり命令のオペコード部分)を読み取り、その値によって処理を振り分けることにします。  
この処理には関数ポインタテーブルinstructionsを利用します。  
  
関数ポインタは、おおざっぱに言うと関数を登録するための配列です。  
オペコードの値を添え字に指定すると、そのオペコードに対応する処理を行う関数を呼び出せる仕組みとなります。
```c
```
