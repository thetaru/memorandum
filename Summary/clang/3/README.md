# 制御文
## 3.1 条件分岐if else構文
条件分岐の際に利用する構文です。
### 3.1.1 if else文の書き方
実際にif else構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  int hoge = 10;
  
  if ( hoge == 10 ) {
    /* 処理A */
  else {
    /* 処理B */
  }
}
```
if構文の場合、if()のカッコの中には条件を書きます。  
カッコの中の条件式が真である場合に処理Aを、偽の場合に処理Bを行います。  
上の例ではhogeの値が10かどうかで場合分けしています。  
  
処理Aしか必要がないときには次のように書くことができます。
```c
if ( hoge == 10 ) {
  /* hoge の値が10の時の処理を書く */
}
```
また条件を複数書きたい場合は次のように記述します。
```c
int hoge = 8;

if ( hoge == 10 ) {
  /* Aの処理 */
} else if ( hoge == 9 ) {
  /* Bの処理 */
} else if ( hoge == 8 ) {
  /* Cの処理 */
} else {
  /* Dの処理 */
}
```
このプログラムの場合は、Cの処理が実行されることになります。
### 3.1.2 非0の判定式
次のようなプログラムを書くこともできます。
```c
int hoge = 1;

if ( hoge ) {
  /* 何か処理を書く */
}
```
条件式にhogeとしか書いてないがこれはどういうことでしょうか。  
実はこういう場合、カッコの中の値が0(true)であるか0以外(false)であるかを判定します。  
つまり上記の式は以下のコードと同じ意味です。
```c
if ( hoge != 0 ) {
  /* 何か処理を書く */
}
```
### 3.1.3 関係演算子
2つの変数を比較し、式が正しいか誤りかを求めるときに使う演算子を**関係演算子**といいます。

|関係演算子|意味|
|:---:|:---|
|x < y|x が y より小さかったら真, そうでなかったら偽|
|x > y|x が y より大きかったら真, そうでなかったら偽|
|x <= y|x が y 以下であれば真, そうでなかったら偽|
|x >= y|x が y 以上であれば真, そうでなかったら偽|
|x == y|x が y と等しければ真, そうでなかったら偽|
|x != y|x が y と等しくなければ真, そうでなかったら偽|

### 3.1.4 論理演算子

|論理演算子|意味|
|:---:|:---|
|A && B|AかつB|
|A \|\| B|AまたはB|
|!A|Aの否定|

Aの否定について例を加えておきます。  
```c
int hoge = 10;
if ( !hoge ) {
  /* Aの処理 */
}
```
条件が!hogeではなくhogeであった場合、非ゼロの判定式により処理Aが実行されます。  
しかしこの場合はhogeが0以外の場合は条件が偽となり、処理Aが実行されません。  
つまり非ゼロの判定式の真偽を逆転することになります。
## 3.2 条件分岐switch構文
次はswitch構文を学びます。  
条件分岐の数が多いときに役立ちます。  
実際にswitch構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  int hoge = 10;
  
  switch ( hoge ) {
  /* hoge == 10 */
  case 10: /* 処理A */
    break;
  /* hoge == 9  */
  case 9:  /* 処理B */
    break;
  /* hoge == 8  */
  case 8:  /* 処理C */
    break;
  /* else */
  default: /* 処理D */
    break;
  }
  /* 処理E */
}
```
switchに続くカッコの中には変数をいれます。このカッコ内に入れることができるのは整数の値のみです。  
**case**にはその整数値に応じた処理を記述します。  
**default**には各caseに当てはまらなかった場合の処理を記述します。  
  
各caseでbreakを入れているのには理由があり、変数(上の例だとhoge)が複数case(とdefault)にマッチしてしまうことを止めるためです。  
※ 逆に複数条件にマッチしてもいい場合(fall throughという)はbreakを入れる必要はないといえます。
## 3.3 繰り返し do while for構文
do while for構文は繰り返し処理を行いたい場合に利用します。
### 3.3.1 do while構文
#### Syntax
```c
do { 処理 } while ( 条件式 );
```
実際にdo while構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  int hoge = 10;
  
  do {
    printf("%d回目: Hello World\n", 11 - hoge);
    hoge --;
  } while ( hoge > 0 );
  
  return 0;
}
```
do { }の中に何か処理を書きます。そしてwhile ( )の中に条件式を書きます。  
繰り返しはこの条件が真の場合に行われ、一度でも条件が偽になったら繰り返しを打ち切ります。
### 3.3.2 while構文
#### Syntax
```c
while ( 条件式 ) { 処理 }
```
do while と whileの違いは条件式を最初に判定するか後で判定するかの違いです。  
このような違いからdo while構文は少なくとも1回は処理が実行されますが、while構文は一度も実行されないことがあります。  
実際にwhile構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>

int main(void)
{
  int hoge = 10;
  
  while ( hoge > 0 ) {
    printf("%d回目: Hello World\n", 11 - hoge);
    hoge--;
  }
  return 0;
}
```
### 3.3.3 for構文
#### Syntax
```c
for ( 初期条件; 条件式; 後始末 ) { 処理 }
```
初期条件には変数の初期化などを書きます。条件式はifと同じです。後始末には処理の最後まで実行した後、後始末の処理が実行されます。  
実際にfor構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>

int main(void)
{
  int hoge;
  
  for ( hoge = 10; hoge > 10; hoge-- ) {
    printf("%d回目: Hello World\n", 11 - hoge);
  }
  return 0;
}
```
### 3.3.4 breakを使ったループの脱出
繰り返し処理を実行している間にbreakを使うと、いつでもループから脱出することができます。  
実際にプログラムを書いてみます。
```c
#include <stdio.h>

int main(void)
{
  int i;
  
  for ( i = 0; i < 10; i++ ) {
    printf("i = %d\n", i);
    if ( i == 5 ) {
      printf("Before break");
      break
      printf("After break")
    }
  }
  return 0;
```
このプログラムを実行すると`Before break`は出力されますが`After break`が出力されないこと(繰り返し処理の終わり)がわかります。
### 3.3.5 continue文
continueはループの次の繰り返しをすぐさま実行したい場合に使用されます。  
実際にプログラムを書いてみます。
```c
#include <stdio.h>

int main(void)
{
  int i;
  
  for ( i = 0; i < 5; i++ ) {
    printf("i = %d\n", i);
    if ( i <= 2 ) {
      continue;
    }
    printf("LOOP");
  }
  return 0;
}
```
このプログラムではcontinue文に到達した時点で次の繰り返し処理を実行するためiが2以下の場合には`LOOP`が出力されません。
## 3.4 ビット演算
### 3.4.1 ビットごとの演算子

|記号|意味|
|:--:|:---|
|&|ビットごとのAND|
|\||ビットごとのOR|
|^|ビットごとのXOR|
|~|NOT|

#### AND
すべてのビットが1であるときのみ1を返します。  
|第一引数|演算子|第二引数|演算結果|
|:---:|:---:|:---:|:---:|
|0|&|0|0|
|0|&|1|0|
|1|&|0|0|
|1|&|1|1|

#### OR
いずれかのビットが1である場合に1を返します。
|第一引数|演算子|第二引数|演算結果|
|:---:|:---:|:---:|:---:|
|0|\||0|0|
|0|\||1|1|
|1|\||0|1|
|1|\||1|1|

#### XOR
全てのビットが0または1の場合に0を返します。
|第一引数|演算子|第二引数|演算結果|
|:---:|:---:|:---:|:---:|
|0|^|0|0|
|0|^|1|1|
|1|^|0|1|
|1|^|1|0|

#### NOT
ビットを反転させます。
|演算子|第一引数|演算結果|
|:---:|:---:|:---:|
|~|0|1|
|~|1|0|

### 3.4.2 シフト演算子
ビットをシフトさせるシフト演算子があります。  
例えば、
```
00000011
```
を左に2つシフトすると、
```
00001100
```
となります。  
左シフトは10進数で考えると値に2^(シフト数)を掛けていることだとわかります。
## 3.5 例題
### 3.5.2 最大値を求めるプログラム
解答がミスってるので訂正
```c
#incude <stdio.h>

int main(void) {
  int array[10];
  int i, j, max;
  
  printf("10個の数字を入力してください\n");
  
  for ( i = 0; i < 10; i++ ) {
    printf("%d回目: ", i+1);
    scanf("%d", &array[i]);
  }
  
  for ( j = 1, max = array[0]; j < 10; j++ ) {
    if ( max < array[j] ) {
      max = array[j];
    }
  }
  
  printf("最大値は%d\n", max);
  return 0;
}
}
```
