# 制御文
## 3.1 条件分岐if else構文
条件分岐の際に利用する構文です。
### 3.1.1 if else文の書き方
実際にif else構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  int hoge = 10;
  
  if ( hoge == 10 ) {
    /* 処理A */
  else {
    /* 処理B */
  }
}
```
if構文の場合、if()のカッコの中には条件を書きます。  
カッコの中の条件式が真である場合に処理Aを、偽の場合に処理Bを行います。  
上の例ではhogeの値が10かどうかで場合分けしています。  
  
処理Aしか必要がないときには次のように書くことができます。
```c
if ( hoge == 10 ) {
  /* hoge の値が10の時の処理を書く */
}
```
また条件を複数書きたい場合は次のように記述します。
```c
int hoge = 8;

if ( hoge == 10 ) {
  /* Aの処理 */
} else if ( hoge == 9 ) {
  /* Bの処理 */
} else if ( hoge == 8 ) {
  /* Cの処理 */
} else {
  /* Dの処理 */
}
```
このプログラムの場合は、Cの処理が実行されることになります。
### 3.1.2 非0の判定式
次のようなプログラムを書くこともできます。
```c
int hoge = 1;

if ( hoge ) {
  /* 何か処理を書く */
}
```
条件式にhogeとしか書いてないがこれはどういうことでしょうか。  
実はこういう場合、カッコの中の値が0(true)であるか0以外(false)であるかを判定します。  
つまり上記の式は以下のコードと同じ意味です。
```c
if ( hoge != 0 ) {
  /* 何か処理を書く */
}
```
### 3.1.3 関係演算子
2つの変数を比較し、式が正しいか誤りかを求めるときに使う演算子を**関係演算子**といいます。

|関係演算子|意味|
|:---:|:---|
|x < y|x が y より小さかったら真, そうでなかったら偽|
|x > y|x が y より大きかったら真, そうでなかったら偽|
|x <= y|x が y 以下であれば真, そうでなかったら偽|
|x >= y|x が y 以上であれば真, そうでなかったら偽|
|x == y|x が y と等しければ真, そうでなかったら偽|
|x != y|x が y と等しくなければ真, そうでなかったら偽|

### 3.1.4 論理演算子

|論理演算子|意味|
|:---:|:---|
|A && B|AかつB|
|A \|\| B|AまたはB|
|!A|Aの否定|

Aの否定について例を加えておきます。  
```c
int hoge = 10;
if ( !hoge ) {
  /* Aの処理 */
}
```
条件が!hogeではなくhogeであった場合、非ゼロの判定式により処理Aが実行されます。  
しかしこの場合はhogeが0以外の場合は条件が偽となり、処理Aが実行されません。  
つまり非ゼロの判定式の真偽を逆転することになります。
## 3.2 条件分岐switch構文
次はswitch構文を学びます。  
条件分岐の数が多いときに役立ちます。  
実際にswitch構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  int hoge = 10;
  
  switch ( hoge ) {
  /* hoge == 10 */
  case 10: /* 処理A */
    break;
  /* hoge == 9  */
  case 9:  /* 処理B */
    break;
  /* hoge == 8  */
  case 8:  /* 処理C */
    break;
  /* else */
  default: /* 処理D */
    break;
  }
  /* 処理E */
}
```
switchに続くカッコの中には変数をいれます。このカッコ内に入れることができるのは整数の値のみです。  
**case**にはその整数値に応じた処理を記述します。  
**default**には各caseに当てはまらなかった場合の処理を記述します。  
  
各caseでbreakを入れているのには理由があり、変数(上の例だとhoge)が複数case(とdefault)にマッチしてしまうことを止めるためです。  
※ 逆に複数条件にマッチしてもいい場合(fall throughという)はbreakを入れる必要はないといえます。
## 3.3 繰り返し do while for構文
do while for構文は繰り返し処理を行いたい場合に利用します。
### 3.3.1 do while構文
#### Syntax
```c
do { 処理 } while ( 条件式 );
```
実際にdo while構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  int hoge = 10;
  
  do {
    printf("%d回目: Hello World\n", 11 - hoge);
    hoge --;
  } while ( hoge > 0 );
  
  return 0;
}
```
do { }の中に何か処理を書きます。そしてwhile ( )の中に条件式を書きます。  
繰り返しはこの条件が真の場合に行われ、一度でも条件が偽になったら繰り返しを打ち切ります。
### 3.3.2 while構文
#### Syntax
```c
while ( 条件式 ) { 処理 }
```
do while と whileの違いは条件式を最初に判定するか後で判定するかの違いです。  
このような違いからdo while構文は少なくとも1回は処理が実行されますが、while構文は一度も実行されないことがあります。  
実際にwhile構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>

int main(void)
{
  int hoge = 10;
  
  while ( hoge > 0 ) {
    printf("%d回目: Hello World\n", 11 - hoge);
    hoge--;
  }
  return 0;
}
```
### 3.3.3 for構文
#### Syntax
```c
for ( 初期条件; 条件式; 後始末 ) { 処理 }
```
初期条件には変数の初期化などを書きます。条件式はifと同じです。後始末には処理の最後まで実行した後、後始末の処理が実行されます。  
実際にfor構文を使ってプログラムを書いてみます。
```c
#include <stdio.h>

int main(void)
{
  int hoge;
  
  for ( hoge = 10; hoge > 10; hoge-- ) {
    printf("%d回目: Hello World\n", 11 - hoge);
  }
  return 0;
}
```
