# 変数について
## 2.1 型の種類
変数には以下のような型があります。

|型の名前|意味|範囲|
|:---|:---|:---:|
|short|整数値|-32768 ～ +32767|
|int|整数値|-2147483648 ～ +2147483647|
|long|整数値|-2147483648 ～ 2147483647|
|unsigned short|符号なし整数|0 ～ +65535|
|unsigned int|符号なし整数|0 ～ +4294967295|
|unsigned long|符号なし整数|0 ～ +4294967295|
|char|1文字|-128 ～ +127 または 0 ～ +255|
|unsigned char|符号なし1文字|0 ～ +255|
|float|浮動小数点数|3.4 * 10^-38 ～　 3.4 * 10^+38|
|double|浮動小数点数|1.7 * 10^-308 ～　 1.7 * 10^+308|

情報が古いかも?  
charは1文字なのになぜと思うかもしれませんが、文字と数値の対応(文字コード表)を見れば納得できると思います。

## 2.2 変数の作り方
int型の変数を作りたい場合は次のように宣言します。
```c
int hoge;
```
同様にdouble型の変数を作りたい場合は次のように宣言します。
```c
double piyo;
```
同じ型の変数を複数同時に宣言したい場合は次のように記述できます。
```c
double foo, bar;
```
## 2.3 変数名名の際の注意
次のようなルールがあります。
- 先頭は英字かアンスコ(_)のみ
- 同じ変数名は基本NG
- 予約語は使用不可

## 2.4 変数への値の代入
**代入**はもともと宣言してある変数に値を入れることです。  
変数に値を代入には次のように記述します。
```c
int hoge;
hoge = 10;
```
以下は値を既に入れた状態で宣言しているので代入ではなく**初期化**です。
```c
int hoge = 10;
```
## 2.5 変数値を表示する
変数内の値を画面上に出力したい場合、次のようにする。
```c
int hoge;
hoge = 10;
printf("%d", hoge);
```
`%d`は10進数で出力するという意味です。  
`"%d"`の部分は**仮引数**といい、`hoge`の部分を**実引数**という。  
上の例だと仮引数を実引数に置き換えているようなイメージになる。  
この`%`で始まる部分を**変換指定子**といいます。

|記号|意味|
|:---:|:---|
|%d|整数の10進数として出力|
|%u|符号なし整数の10進数として出力|
|%o|整数の8進数として出力|
|%x|整数の16進数として出力|
|%f|小数値表示(floatやdoubleの場合に使用)|
|%c|1文字を出力|
|%s|文字列を出力|
|%p|ポインタの値を出力|
|%%|%を出力|

## 2.6 n進数
特になし

## 2.7 変数使用の際の注意事項
変数を初期化または値を代入しないまま、変数の値を出力するのはNGです。  
また宣言した型に合う値を入れましょう。

## 2.8 const修飾子
変数の型の前に`const`を付けると、変数の値を書き換えることができなくなります。  
ただし初期値を与えることはできます。  
const修飾子は読み込み専用変数を宣言したい際に使用します。  
  
次の例では読み込み可能であることがわかります。
```c
#include <stdio.h>
int main(void)
{
  const int i = 5;
  printf("%d", i);
  return 0;
}
```
次の例ではconst指定した変数値に値を代入できないことがわかります。
```c
#include <stdio.h>
int main(void)
{
  const i = 5;
  i = 10; /* compile error*/
  return 0;
}
```
## 2.9 演算
四則演算ができます。

|記号|意味|
|:---:|:---:|
|+|足し算|
|-|引き算|
|\*|掛け算|
|/|割り算|

次に簡単な例を示します。
```c
#include <stdio.h>
int main(void)
{
  int x, y;
  
  x = 10;
  y = 20;
  printf("x+y equals %d\n", x + y);
  y = y - x;
  printf("y equals %d\n", y);
  return 0;
}
```
### 2.9.1 商を求める際の注意
ゼロ除算はNG
### 2.9.2 その他の演算
符号の反転をしたい場合は次のようにします。
```c
int x = 10;
printf("%d\n", -x);
```
剰余を求めたい場合は次のようにします。
```c
int x = 10, y = 3;
printf("residue is %d\n", x % y);
```
### 2.9.3 略した式

|略式|意味|
|:---|:---|
|x += y|x = x + y|
|x -= y|x = x - y|
|x \*= y|x = x \* y|
|x /= y|x = x / y|
|x += 1|x++|
|x -= 1|x--|

### 2.9.4 べき乗の計算の注意
特になし

## 2.10 キャスト
C言語では計算を行う際は必ず同じ型でないといけません。  
例えば次のようなコードがあるとします。
```c
double dx = 10.0, dz;
int iy = 3;

dz = dx / iy;
```
この例では`int`型と`double`型との違う型同士の計算をした場合は、**格上げ**という暗黙の型変換が自動的に行われます。  
ここではiyの型が一時的にdouble型に変換されます。  
暗黙の型変換ではより大きい型に合わせて変換される(e.g. int型とdouble型ならint型のほうがdouble型に変換される)ことに注意しましょう。  
  
明示的に型変換をする場合は次のように記述します。
```c
double dy = 10.0, dz;
int iy = 3;
dz = (int)dy / iy;
```
この例のように変数dyの型をint型に一時的に変換する場合、dyの前に(int)と書きます。
他の型でも同様に変換することができます。  
このような型変換を**キャスト**といいます。

## 2.11 scanf関数
キーボードからの入力待ちをして、取得した値を変数に代入する方法について考えます。  
こういう場合に使うのがscanf関数です。  
次のように使用します。
```c
#include <stdio.h>
int main(void)
{
  int x;
  
  printf("Input number: ");
  scanf("%d", &x);
  printf("Recieved %d from keyboard\n", x);
  return 0;
}
```
scanfの実引数が`x`ではなく`&x`にっていることに注意しましょう。  
`&x`とはxのポインタのことです。(キーボードからの入力によって取得した値をxの先頭アドレスへのポインタに書き込みます。)

## 2.12 配列
複数の同じ型の変数をひとまとまりのデータとして扱いときに使います。
### 2.12.1 一次元配列
int型の変数を5個持つ配列を宣言してみます。
```c
int hoge[5];
```
同様にint型の変数を100個持つ配列を宣言してみます。
```c
int hoge[100];
```
### 2.12.2 配列への値の代入
配列を宣言した後は値を代入します。  
配列の一番最初の変数に10を代入する場合は次のように記述します。
```c
int hoge[5];
hoge[0] = 10;
```
配列の添え字(e.g. hoge[0], hoge[1],...)は必ず`0`から始まりであることに注意しましょう。  
そのため上の例ではhoge[5]は存在しません(存在すると変数を6つ持ってしまうことになるため)。
### 2.12.3 配列の初期化
変数と同様に配列も初期化することができます。  
配列の初期化は次のように記述します。  
やっていることはだいたい変数のときと同じです。  
```c
int hoge[5] = { 1, 2, 3, 4, 5 };
```
  
次のようにした場合は足りない部分に0が自動的に代入されます。
```c
int hoge[5] = { 1, 2 };
```  
つまり次と同じです。
```c
int hoge[5] = { 1, 2, 0, 0, 0 };
```
  
次のように配列の長さを指定せず配列を初期化することもできます。  
この場合、配列の長さは初期値に依存することになります。
```c
int hoge[] = { 1, 2, 3, 4, 5 };
```
この場合はコンパイラが自動的に要素数を設定してくれます。(これの例では5つの要素で初期化しているのでhogeの要素数は5となります)
### 2.12.4 文字配列
charは1文字だけですがchar型の配列を使うことで文字列が扱えるようになります。  
文字列の復習もかねてわざと冗長に書いてみます。
```c
char str[6] = { 'H', 'E', 'L', 'L', 'O', '\0' };
printf("%c%c%c%c%c%c", str[0], str[1], str[2], str[3], str[4], str[5]);
```
`\0`はNULL文字です。※ `1.3.4 エスケープシークエンス`で扱いました。  
文字列の最後に必ず入れなければいけない特殊文字です。  
このNULL文字があることで文字列の終わりをコンパイラが検知します。  
  
上の1文字ずつ表示する冗長な書き方は面倒なので`%s`を使用して出力してみます。
```c
char str[6] = { 'H', 'E', 'L', 'L', 'O', '\0' };
printf("%s", str);
```
実はこの配列を渡すという行為はstrの先頭アドレス(&str[0])を渡していることに等しいです。  
今度は配列の初期化の部分をさらに簡単に記述します。
```c
char str[6] = {"HELLO"};
```
さらに略すこともできます。
```c
char str[6] = "HELLO";
```
これらの略した初期化ではNULL文字`\0`が付いていませんがコンパイルする過程で文字列の変数の末尾に`\0`が付け加えられます。  
次のような場合には注意してください。
```c
char str[5] = "HELLO";
```
この場合、配列の長さが5で"HELLO"の長さも5なのでNULL文字を入れることができません。
### 2.12.5 キーボードから文字列の入力
キーボードから文字列の入力を受け取る場合もscanf関数を使用します。  
次のように記述します。
```c
#include <stdio.h>
int main(void)
{
  char str[6];
  
  printf("Enter a character: ");
  scanf("%s", str);
  printf("%s\n", str);
  return 0;
}
```
printf関数と同様にscanf関数の場合も`%s`を使うことで文字列の代入ができます。  
しかし`2.11 scanf関数`でscanf関数の実引数は変数のポインタを渡すように言っていますが上の例では`&str`となっていません。  
これは変数strの実態がchar型の配列であり、配列を渡すことはその配列の先頭アドレス(&str[0])を渡すことに等しいという理由からです。  
つまりstrを渡していても実際には&str[0]を渡しているということです。(strを&str[0]に書き換えても同じ挙動をします。)
### 2.12.6 scanf使用時の注意点
scanf関数の`%s`はスペース、改行、タブがくると読み込みを終了してしまうことに注意しましょう。  
つまりスペース、改行、タブ以降の文字列は読み込まれません。
## 2.13 文字コード
char型に格納できる値の範囲は整数の -128 ~ 127 だったけど実際に入れている値は'a'などの1文字なのでなんでだろなって話です。  
実はchar型変数に格納されている1文字が例えば'A'であっても、それと紐づいている実際の値は97であるって感じになっています。  
次の2つのコードは同じ意味となります。
```c
char hoge;
hoge = 97;
```
```c
char hoge;
hoge = 'a';
```
実際に出力してみると'a'が出力されることがわかります。  
何らかの文字と何らかの整数値(-128 ~ 127)は一対一で対応してるんだな～って思っていればいいです。
### 2.13.1 文字コード表
上で書いた通り対応表のようなものがあるってだけ
### 2.13.2 数字の注意点
例えばchar型では`1`と`'1'`は違うということです。
### 2.13.3 日本語について
charの範囲は256通りあるけど漢字、ひらがな、カタカナ分は足りてないよね大丈夫?  
よく知らないけど工夫しているっぽい
### 2.13.4 文字化けについて
文字コードの対応の仕方は1種類でないことから起こります。  
## 2.14 例題
### 2.14.1 メートルをフィートへ変換するプログラム
特になし
### 2.14.2 空白を読み込むscanf
特になし
## 2.15 演習問題
どれも難しくない
