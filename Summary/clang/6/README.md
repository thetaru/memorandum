# ポインタ
## 6.1 ポインタとは
ポインタとは**メモリのアドレスを保存する**変数です。
```
int hoge = 5 と int* p_hoge = &hoge(=0x100)をメモリで表した図です。
-----------------------------------------------------------------------------------------
|       |       |  int  |       |       |       |       |       |  int* |       |       |
|   ~   |  ...  |   5   |  ...  |       |   ~   |       |  ...  | 0x100 |  ...  |   ~   |
|       |       | 0x100 |       |       |       |       |       | 0x150 |       |       |
-----------------------------------------------------------------------------------------
```
p_hogeの値がhogeのアドレスになっていることがわかります。  
hogeはint型の値を保持する変数でp_hogeはint型の変数を指すポインタ型にint型変数hogeのアドレスを代入した変数です。  
この例ではint型のポインタを考えましたが変数の型によって変更する必要があることに注意します。  
  
### ポインタの宣言方法
int型の変数を指すポインタ型を宣言する方法は2種類あります。
```c
int* p_hoge;
または
int *p_hoge;
```
違いは複数個の変数を同時に宣言する際に出ます。  
**前者**の場合
```c
/* p_hoge: ポインタ型 */
/* p_fuga: int型 */
int* p_hoge, p_fuga;
```
**後者**の場合
```c
/* p_hoge: ポインタ型 */
/* p_fuga: ポインタ型 */
int *p_hoge, *p_fuga;
```
例としてintのポインタ型で宣言していますが他の型に関しても同様に宣言できます。  
## 6.2 ポインタへの値の代入
`&`は指定した変数のアドレスを取得するのに使います。
```c
/* 変数の宣言 */
int hoge;
int* p_hoge;

hoge = 10;
p_hoge = &hoge; /* hogeのアドレスを代入します */
```
## 6.3 ポインタによる変数値の参照
実際にプログラムを書いてみます。  
printf関数でアドレスを出力するときは変換指定子に`%p`を使います。
```c
#include <stdio.h>

int main(void)
{
  int hoge;
  int* p_hoge;
  
  hoge = 5;
  p_hoge = &hoge;
  
  printf("hoge address: %p\n", &hoge);
  printf("hoge: %d\n", hoge);
  printf("p_hoge address: %p\n", &p_hoge);
  printf("p_hoge: %p\n", p_hoge);
  printf("*p_hoge: %d\n", *p_hoge);
}
```
実行結果は以下のようになります。(環境によって変化します。)
```c
hoge address: 0x7ffdf1cb621c
hoge: 5
p_hoge address: 0x7ffdf1cb6210
p_hoge: 0x7ffdf1cb621c
*p_hoge: 5
```
`hoge`と`*p_hoge`は同じ値をしていることがわかります。  
つまり`*p_hoge`とは`p_hoge`が持っているアドレスにあるデータを持ってきます。  
#### 注意事項
\*記号を使うタイミングは以下の2通りがあります。  
- ポインタの宣言
- ポインタが持っているアドレスのデータの取得

ポインタ宣言時の\*と，データアクセス時の\*は別物であることに注意してください。
### 任意の変数の型に対して有効なポインタ
実は`void*型`が存在します。  
実際にvoid\*型を使ったプログラムを書いてみます。
```c
int main(void)
{
  int hoge = 10;
  void* p_hoge = &hoge;
  
  /* bar = *p_hoge はできないのでキャスト変換していきます */
  /* barにはhogeの値(=10)が入ります */
  int bar = *( (int*)p_hoge );
  
  return 0;
}
```
変数に値を代入する場合は、代入される側とされる側の型が一致している必要があります。
## 6.4 NULLポインタ
次のコード片を考えてみます。
```c
int hoge;
printf("%d\n", hoge);
```
このとき出力はどうなるでしょうか?  
答えは不定です。(実験してみてください。)  
  
同様に次のコード片を考えてみます。
```c
int* p_hoge;
printf("%d\n", p_hoge);
```
このとき出力はどうなるでしょうか?  
答えは不定です。(実験してみてください。)  
  
このようにC言語では変数を初期化しないとその変数の初期値にめちゃくちゃな値が入ってしまいます。  
なので変数は必ず初期値を設定し、初期化を行う習慣をつけてください。  
  
`int* p_hoge`がどこも指していない状態を作りたい場合どうすればいいでしょうか?  
そのような状態を作り出したい場合は次のように書きます。
```c
int* p_hoge;
p_hoge = NULL;
```
これでp_hogeはどこも指していないということになります。  
## 6.5 引数としてのポインタ
ここではポインタの使い方について解説します。  
次のようなswap関数を作ったとします。
```c
void swap( int x, int y )
{
  int tmp = x;
  x = y;
  y = tmp;
} 
```
このコードでは、2つの変数を引数として受け取り、その中身を交換する関数を作ったつもりです。  
次のようなコードを書き実行させて見ましょう。
```c
#include <stdio.h>

void swap( int x, int y )
{
  int tmp = x;
  x = y;
  y = tmp;
}

int main(void)
{
  int hoge = 10, piyo = 5;
  
  swap( hoge, piyo );
  printf("hoge: %d, piyo: %d\n", hoge, piyo);
  return 0;
}
```
このswap関数ではうまく値を交換できていません。  
`4.2 関数を作ってみる`で仮引数には実引数のコピーが渡されると説明したことを思い出してください。  
仮引数を書き換えても元の変数hogeとpiyoには影響はありません。(仮引数はあくまでもhogeとpiyoのコピーにすぎないので)  
そこでポインタを使って元の変数に直接アクセスして値を書き換える手段を考えます。  
実際にプログラムを書いてみます。
```c
#include <stdio.h>

void swap(int* x, int* y);

int main(void)
{
  int hoge = 10, piyo = 5;
  
  swap( &hoge, &piyo );
  printf("hoge: %d, piyo: %d\n", hoge, piyo);
  return 0;
}

void swap(int* x, int* y)
{
  int tmp = *x;
  *x = *y;
  *y = tmp;
}
```
x, yはポインタ型なのでswap関数内の`*x`はhogeの値で`*y`はpiyoの値です。  
実際にこのプログラムを実行してみると値が交換されていることがわかります。  
直接アドレスに対してアクセスし値を変更するイメージです。
## 6.6 ポインタの型
変数の型の大きさについて学びます。
### 6.6.1 sizeof
`sizeof`は、ある型が何バイトであるか取得することができます。  
`sizeof`は関数ではなく予約後であることに注意してください。  
実際にコードを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  printf("char型のサイズは%dです\n", sizeof());
  printf("int型のサイズは%dです\n", sizeof(int));
  return 0;
}
```
実行するとそれぞれの型のサイズが出力されます。  
ただし、ここで出力された型のサイズは環境に依存するためあくまでその環境でのサイズです。  
規格上は、int型は2バイト以上となっています。
### 6.6.2 ポインタの型の大きさ
次にポインタ型の大きさを調べてみます。
```c
#include <stdio.h>
int main(void)
{
  printf("char*型のサイズは%dです\n", sizeof(char*));
  printf("int*型のサイズは%dです\n", sizeof(int*));
}
```
実行結果は次のようになりました。
```
char*型のサイズは8です
int*型のサイズは8です
```
ポインタの型のサイズも同様に環境依存です。
### 6.6.3 ポインタを使った配列へのアクセス
```
ここではint型は4バイトと仮定します。
                          Array   Array   Array   Array   Array
                           [0]     [1]     [2]     [3]     [4]
-----------------------------------------------------------------------------------------
|       |       |       |  int  |  int  |  int  |  int  |  int  |       |       |  int* |
|   ~   |  ...  |       |   5   |   1   |   3   |   4   |   9   |       |  ...  | 0x100 |
|       |       |       | 0x100 | 0x104 | 0x108 | 0x112 | 0x116 |       |       | 0x150 |
-----------------------------------------------------------------------------------------
```
## 6.7 配列とポインタ
### 6.7.1 配列とポインタ入門
### 6.7.2 配列とポインタ
### 6.7.3 引数に配列へのポインタを渡す
### 6.7.4 ポインタ配列
## 6.8 文字列定数とポインタ
## 6.9 ポインタのポインタ
## 6.10 例題
## 6.11 演習問題
