# ポインタ
## 6.1 ポインタとは
ポインタとは**メモリのアドレスを保存する**変数です。
```
int hoge = 5 と int* p_hoge = &hoge(=0x100)をメモリで表した図です。
-----------------------------------------------------------------------------------------
|       |       |  int  |       |       |       |       |       |  int* |       |       |
|   ~   |  ...  |   5   |  ...  |       |   ~   |       |  ...  | 0x100 |  ...  |   ~   |
|       |       | 0x100 |       |       |       |       |       | 0x150 |       |       |
-----------------------------------------------------------------------------------------
```
p_hogeの値がhogeのアドレスになっていることがわかります。  
hogeはint型の値を保持する変数でp_hogeはint型の変数を指すポインタ型にint型変数hogeのアドレスを代入した変数です。  
この例ではint型のポインタを考えましたが変数の型によって変更する必要があることに注意します。  
  
### ポインタの宣言方法
int型の変数を指すポインタ型を宣言する方法は2種類あります。
```c
int* p_hoge;
または
int *p_hoge;
```
違いは複数個の変数を同時に宣言する際に出ます。  
**前者**の場合
```c
/* p_hoge: ポインタ型 */
/* p_fuga: int型 */
int* p_hoge, p_fuga;
```
**後者**の場合
```c
/* p_hoge: ポインタ型 */
/* p_fuga: ポインタ型 */
int *p_hoge, *p_fuga;
```
例としてintのポインタ型で宣言していますが他の型に関しても同様に宣言できます。  
## 6.2 ポインタへの値の代入
`&`は指定した変数のアドレスを取得するのに使います。
```c
/* 変数の宣言 */
int hoge;
int* p_hoge;

hoge = 10;
p_hoge = &hoge; /* hogeのアドレスを代入します */
```
## 6.3 ポインタによる変数値の参照
実際にプログラムを書いてみます。  
printf関数でアドレスを出力するときは変換指定子に`%p`を使います。
```c
#include <stdio.h>

int main(void)
{
  int hoge;
  int* p_hoge;
  
  hoge = 5;
  p_hoge = &hoge;
  
  printf("hoge address: %p\n", &hoge);
  printf("hoge: %d\n", hoge);
  printf("p_hoge address: %p\n", &p_hoge);
  printf("p_hoge: %p\n", p_hoge);
  printf("*p_hoge: %d\n", *p_hoge);
}
```
実行結果は以下のようになります。(環境によって変化します。)
```c
hoge address: 0x7ffdf1cb621c
hoge: 5
p_hoge address: 0x7ffdf1cb6210
p_hoge: 0x7ffdf1cb621c
*p_hoge: 5
```
`hoge`と`*p_hoge`は同じ値をしていることがわかります。  
つまり`*p_hoge`とは`p_hoge`が持っているアドレスにあるデータを持ってきます。  
#### 注意事項
\*記号を使うタイミングは以下の2通りがあります。  
- ポインタの宣言
- ポインタが持っているアドレスのデータの取得

ポインタ宣言時の\*と，データアクセス時の\*は別物であることに注意してください。
### 任意の変数の型に対して有効なポインタ
実は`void*型`が存在します。  
実際にvoid\*型を使ったプログラムを書いてみます。
```c
int main(void)
{
  int hoge = 10;
  void* p_hoge = &hoge;
  
  /* bar = *p_hoge はできないのでキャスト変換していきます */
  /* barにはhogeの値(=10)が入ります */
  int bar = *( (int*)p_hoge );
  
  return 0;
}
```
変数に値を代入する場合は、代入される側とされる側の型が一致している必要があります。
## 6.4 NULLポインタ
次のコード片を考えてみます。
```c
int hoge;
printf("%d\n", hoge);
```
このとき出力はどうなるでしょうか?  
答えは不定です。(実験してみてください。)  
  
同様に次のコード片を考えてみます。
```c
int* p_hoge;
printf("%d\n", p_hoge);
```
このとき出力はどうなるでしょうか?  
答えは不定です。(実験してみてください。)  
  
このようにC言語では変数を初期化しないとその変数の初期値にめちゃくちゃな値が入ってしまいます。  
なので変数は必ず初期値を設定し、初期化を行う習慣をつけてください。  
  
`int* p_hoge`がどこも指していない状態を作りたい場合どうすればいいでしょうか?  
そのような状態を作り出したい場合は次のように書きます。
```c
int* p_hoge;
p_hoge = NULL;
```
これでp_hogeはどこも指していないということになります。  
## 6.5 引数としてのポインタ
ここではポインタの使い方について解説します。  
次のようなswap関数を作ったとします。
```c
void swap( int x, int y )
{
  int tmp = x;
  x = y;
  y = tmp;
} 
```
この関数では、2つの変数を引数として受け取り、その中身を交換する関数を作ったつもりです。  
次のようなコードを書き実行させて見ましょう。
```c
#include <stdio.h>

void swap( int x, int y )
{
  int tmp = x;
  x = y;
  y = tmp;
}

int main(void)
{
  int hoge = 10, piyo = 5;
  
  swap( hoge, piyo );
  printf("hoge: %d, piyo: %d\n", hoge, piyo);
  return 0;
}
```
実際に実行してみると、このswap関数ではうまく値を交換できていません。  
`4.2 関数を作ってみる`で仮引数には実引数のコピーが渡されると説明したことを思い出してください。  
仮引数を書き換えても元の変数hogeとpiyoには影響はありません。(仮引数はあくまでもhogeとpiyoのコピーにすぎないので)  
そこでポインタを使って元の変数に直接アクセスして値を書き換える手段を考えます。  
実際にプログラムを書いてみます。
```c
#include <stdio.h>

void swap(int* x, int* y);

int main(void)
{
  int hoge = 10, piyo = 5;
  
  swap( &hoge, &piyo );
  printf("hoge: %d, piyo: %d\n", hoge, piyo);
  return 0;
}

void swap(int* x, int* y)
{
  int tmp = *x;
  *x = *y;
  *y = tmp;
}
```
ここでx, yはポインタ型なのでmain関数内で呼び出されるswap関数の`*x`はhogeの値で`*y`はpiyoの値です。  
実際にこのプログラムを実行してみると値が交換されていることがわかります。  
直接アドレスに対してアクセスし値を変更するイメージです。
## 6.6 ポインタの型
変数の型の大きさについて学びます。
### 6.6.1 sizeof
`sizeof`は、ある型が何バイトであるか取得することができます。  
`sizeof`は関数ではなく予約語であることに注意してください。  
実際にコードを書いてみます。
```c
#include <stdio.h>
int main(void)
{
  printf("char型のサイズは%dです\n", sizeof(char));
  printf("int型のサイズは%dです\n", sizeof(int));
  return 0;
}
```
実行するとそれぞれの型のサイズが出力されます。  
ただし、ここで出力された型のサイズは環境に依存するためあくまでその環境でのサイズです。  
規格上は、int型は2バイト以上となっています。
### 6.6.2 ポインタの型の大きさ
次にポインタ型の大きさを調べてみます。
```c
#include <stdio.h>
int main(void)
{
  printf("char*型のサイズは%dです\n", sizeof(char*));
  printf("int*型のサイズは%dです\n", sizeof(int*));
}
```
実行結果は次のようになりました。
```
char*型のサイズは8です
int*型のサイズは8です
```
ポインタの型のサイズも同様に環境依存です。
### 6.6.3 ポインタを使った配列へのアクセス
```
ここではint型は4バイトと仮定します。
int型Arrayのアドレスは0x100から始まり4byteずつ割り振られています。
ArrayのポインタpはArrayの先頭アドレス0x100を指しています。
                          Array   Array   Array   Array   Array
                           [0]     [1]     [2]     [3]     [4]                      p
-------------------------------------------------------------------------------------------------
|       |       |       |  int  |  int  |  int  |  int  |  int  |       |       |  int* |       |
|   ~   |  ...  |       |   5   |   1   |   3   |   4   |   9   |       |  ...  | 0x100 |   ~   |
|       |       |       | 0x100 | 0x104 | 0x108 | 0x112 | 0x116 |       |       | 0x150 |       |
-------------------------------------------------------------------------------------------------
```
上の図をプログラムにして書いてみます。
```c
#include <stdio.h>

int main(void)
{
  int array[5] = { 5, 1, 3, 4, 9 };
  int* p;
  
  p = &array[0];
  
  printf("p[0] = %d\n", *p);
  p++; /* これは+4バイトの意味がある */
  printf("p[1] = %d\n", *p);
}
```
実行結果は`array[0]`と`array[1]`の値が出力されます。  
実行結果と上図から`p++(p=p+1)`が`0x100+0x001=0x101`でなく`0x100+0x004=0x104`と計算していることがわかります。  
実はポインタのインクリメントは次の要素を指すようにしています。(つまり型の大きさ分アドレスを進めます。)  
例えば、char型なら型の大きさが1バイトなので1バイト分アドレスを進めます。
## 6.7 配列とポインタ
ポインタと配列の違いについて
### 6.7.1 配列とポインタ入門
次のようなコードを書いたとします。
```c
#include <stdio.h>

int main(void)
{
  int array[5] = { 1, 2, 3, 4, 5 };
  int* p;
  
  p = &array[0];
  
  printf("*(p+0): %d\n", *(p + 0));
  printf("*(p+1): %d\n", *(p + 1));
  printf("*(p+3): %d\n", *(p + 3));
  return 0;
}
```
このコードを図示すると次のようになります。
```
ここではint型は4バイトと仮定します。
                          array   array   array   array   array
                           [0]     [1]     [2]     [3]     [4]                      p
-------------------------------------------------------------------------------------------------
|       |       |       |  int  |  int  |  int  |  int  |  int  |       |       |  int* |       |
|   ~   |  ...  |       |   1   |   2   |   3   |   4   |   5   |       |  ...  | 0x100 |   ~   |
|       |       |       | 0x100 | 0x104 | 0x108 | 0x112 | 0x116 |       |       | 0x150 |       |
-------------------------------------------------------------------------------------------------
```
intのポインタ型`p`に`array[0]`のアドレス(0x100)を代入するには`p=&array[0]`としなければなりませんでした。  
同様に`array[1]`のアドレスを代入するには`p=&array[1]`とします。 
  
次に`*(p+X)`(X=0,1,2,...)の部分を解説します。  
`*p`とは上の図でいうと`0x100`アドレスに格納されたデータのことなので`array[0]`のことです。  
  
`*(p+1)`を考える前に`6.6.3 ポインタを使った配列へのアクセス`でポインタのインクリメント`p++(p=p+1)`が次の要素を指すことを思い出してください。  
すると`p+1`は`array[1]`のアドレス(0x104)を指していることがわかります。  
このことから`*(p+1)`とは上の図でいうと`0x104`アドレスに格納されたデータのことなので`array[1]`のことだとわかります。  
  
`*(p+2)`や`*(p+3)`も同様です。  
  
さて，話を戻します．最初の例を思い出してください．
```c
#include <stdio.h>

int main(void)
{
  int array[5] = { 1, 2, 3, 4, 5 };
  int* p;
  
  p = &array[0];
  
  printf("*(p+0): %d\n", *(p + 0));
  printf("*(p+1): %d\n", *(p + 1));
  printf("*(p+3): %d\n", *(p + 3));
  return 0;
}
```
ここで
```c
p = &array[0];
```
を
```c
p = array;
```
と書いてもよいことになっています。  
つまりポインタ型の変数に配列を渡すと実は**配列の先頭アドレス**が格納されます。
### 6.7.2 配列とポインタ
次のコードを書いたとします。
```c
#include <stdio.h>

int main(void)
{
  int array[5] = { 1, 2, 3, 4, 5 };
  int* p;
  
  p = array;
  
  printf("p[0]: %d\n", p[0]);
  printf("p[1]: %d\n", p[1]);
  printf("*(p+1): %d\n", *(p+1));
  return 0;
}
```
`p[0]`は配列に見えますが、pは配列ではなくarrayのポインタです。  
実は配列のように扱えるようにするために`p[0]=*p=*(p + 0)`となっています。  
`p[1]`も同様に`p[1]=*(p + 1)`と同じです。
### 6.7.3 引数に配列へのポインタを渡す
いままで引数には`int i;`などの変数を渡してきました。  
しかし次のようなこともできます。
```c
#include <stdio.h>

void myPuts(char str[20])
{
  int i;
  for ( i = 0; str[i] != '\0'; i++ ) {
    putchar( str[i] );
  }
  printf("\n");
}

int main(void)
{
  char str[20] = "Hello World";
  myPuts( str );
  return 0;
}
```
myPuts関数の仮引数である`char str[20]`は配列ではなく、ポインタ`char* str`と同じです。  
もちろんmain関数内ではこれら２つは同じ意味ではありません。  
例えば次のように書いたとします。
```c
int main(void)
{
  char str[20];
  char* str2;
}
```
このstrとstr2は別物です。  
あくまで`char str[20]`と`char* str`が同じ意味になるのは仮引数のときだけです。  
つまりmyPuts関数は次のように書き換えることができます。
```c
void myPuts(char* str)
{
  int i;
  for ( i = 0; str[i] != '\0'; i++ ) {
    putchar(str[i]);
  }
  printf("\n");
}
```
また`void myPuts(char str[])`としても同じ意味になります。  
結局のところ配列を仮引数として渡すと配列の先頭アドレスが渡されます。
### 6.7.4 ポインタ配列
int型の配列を作るようにint\*型の配列も作れます。  
次のようなコードを書いたとします。
```c
#include <stdio.h>

int main(void)
{
  int array[5] = { 1, 2, 3, 4, 5 };
  int* p[5];
  int i;
  
  for ( i = 0; i < 5; i++ ) {
    p[i] = &array[i];
    printf("p[%d]: %p\n", i, p[i]);
  }
  
  *p[0] += 10;
  
  for ( i = 0; i < 5; i++ ) {
    printf("*p[%d]: %d\n", i, *p[i]);
  }
}
```
前半は`p[i]`に`array[i]`のアドレスを代入しているだけです。  
後半の`*p[0] += 10`は`p[0]`の中身のアドレスが指しているデータ(i.e. `*(p[0])`)に10を加える命令です。  
`*p[i]`についても同様に`p[i]`の中身のアドレスが指しているデータ(i.e. `*(p[i])`)を表示しているだけです。
## 6.8 文字列定数とポインタ
### 6.8.1 文字列定数について
文字列定数へのポインタを作ってみます。  
次のコードをみてください。
```c
#include <stdio.h>

int main(void)
{
  char* str = "Hello";
  printf("%s\n", str);
  return 0;
}
```
このコードを図示すると次のようになります。
```
ここではchar型は1バイトと仮定します。

                                                                           str
-------------------------------------------------------------------------------------------------
|       |       | char  | char  | char  | char  | char  | char  |       | char* |       |
|   ~   |  ...  |   H   |   E   |   L   |   L   |   O   |  \0   |  ...  | 0x100 |   ~   |
|       |       | 0x100 | 0x101 | 0x102 | 0x103 | 0x104 | 0x105 |       | 0x150 |       |
-------------------------------------------------------------------------------------------------
```
`str`はcharのポインタ型なので文字列定数の配列の先頭アドレスを指しています。  
加えて、図で(というか宣言の仕方から)わかるとおり文字列定数には変数名がついていないのでポインタを使わない限りアクセスできない変数です。
### 6.8.2 文字列定数と文字配列の違い
`char* str = "Hello"`と`char str2[10] = "Hello"`の違いは何でしょうか。  
まず`str`はcharへのポインタであるのに対し、`str2`は文字配列です。  
それだけでなく重要な違いがあります。次のコードを見てください。
```c
#include <stdio.h>

int main(void)
{
  char* str = "Hello";
  char str2[10] = "Hello";
  
  str[0] = 'B';   /* ERROR */
  str2[0] = 'B';  /* OK    */
  
  return 0;
}
```
`str[0]`は`*(str + 0)`のことなのでstrの先頭アドレスに格納されているデータ'H'です。  
しかし、`str`は文字列定数なので値の書き換えはできません。したがってエラーとなります。  
一方、`str2`は変数なので自由に書き換えることができます。
## 6.9 ポインタのポインタ
## 6.10 例題
## 6.11 演習問題
