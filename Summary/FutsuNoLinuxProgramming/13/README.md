# シグナルにかかわるAPI
## 13.1 シグナル
シグナルは、ユーザ(端末)やカーネルがプロセスに何かを通知する目的で使われます。  
シグナルにはいくつか種類があり、マクロで名前が付けられていますが、その実態はint型の整数値です。  
  
プロセスで特に設定をしていない場合は、配送されたシグナルの扱いをカーネルが決定し、処理します。  
処理方法は次の3つです。
1. 無視する
> SIGCHILD
2. プロセスを終了させる
> SIGINT
3. プロセスのコアダンプを作成して異常終了させる
> SIGSEGV

※ コアダンプとは、プロセスが使用するメモリのスナップショットのことです。

|シグナル名|捕捉|挙動|原因と用途|
|:---|:---|:---|:---|
|SIGINT|○|終了|割り込み</br>プログラムを中止したいときに使う|
|SIGHUP|○|終了|ユーザがログアウトしたときなどに生成される</br>デーモンプロセスでは設定ファイルの読み直しに使うことが多い|
|SIGPIPE|○|終了|切れたパイプに書き込むと生成される|
|SIGTERM|○|終了|プロセスを終了させるときに使う</br>killでシグナルを指定しなかったときのデフォルトの値|
|SIGKILL|×|終了|確実にプロセスを終了させるために使う|
|SIGCHILD|○|無視|子プロセスが停止または終了したときに生成される|
|SIGSEGV|○|コアダンプ|アクセスが禁止されているメモリ領域にアクセスしたときに生成される|
|SIGBUS|○|コアダンプ|アラインメント違反(ポインタ操作を間違えた時など)時に生成される|
|SIGFPE|○|コアダンプ|算術演算のエラー(ゼロ除算や浮動小数点のオーバーフローなど)によって生成される。|

### ■ シグナルの捕捉
シグナルの捕捉とは、そのシグナルが配送されたときの挙動を変更することができます。  
シグナルを受けた時のデフォルトの挙動はsigaction()というAPIを使って変更することが可能です。

## 13.2 シグナルを捕捉する
シグナルの処理をカーネルに任せず、自分でシグナルを捕捉(トラップ)するしてみます。
### ■ signal(2)
```c
#include <signal.h>

void (*signal(int sig, void (*func) (int)))(int);
```
見づらいのでtypedefを使って整形します。
```c
typedef void (*sighandler_t)(int);
sighandler_t signal(int sig, sighandler_t func);
```
sighandler_tのtypedefについて説明します。  
sighandler_t型とは、引数がint型で戻り値がvoidの関数へのポインタです。  
  

|引数|意味|
|:---|:---|
|sig|シグナル番号|
|func|シグナルハンドラ|

|戻り値|意味|
|:---|:---|
|成功|今まで設定していたハンドラ(SIG_DFL, SIG_IGN, シグナルハンドラfuncのアドレス)|
|失敗|SIG_ERR|
  
signal()は、シグナル番号sigのシグナルを受けたときの挙動を変更します。  
具体的には、シグナルを受けた時に第2引数funcの関数を呼ぶように挙動を変更します。  
  
このとき第2引数funcに渡す関数を、シグナルを処理する関数という意味でシグナルハンドラといいます。  
また、第2引数funcには次の表に示す特別な値も使えます。

|定数|意味|
|:---|:---|
|SIG_DFL|OSのデフォルト動作に戻す|
|SIG_IGN|カーネルレベルでシグナルを無視するように指示する|

最後に、signal()は直前までのシグナルハンドラを返します。

### ■ 関数ポインタ
関数ポインタについて説明します。  
使用例
```c
#include <stdio.h>
#include <stdlib.h>

int plus1(int n)
{
  return n + 1;
}

int main(int argc, char* argv[])
{
  int (*f)(int);          /* 関数を指すポインタ変数fを定義 */
  int result;
  
  f = plus1;              /* ポインタ変数fに関数plus1のポインタを代入している */
  result = f(5);          /* fに代入した関数(plus1)を実行 */
  printf("f result: %d\n", result);
  printf("plus1 address: %p\n", plus1);
  printf("f address: %p\n", f);
  exit(0);
}
```
`f = plus1`はplus1()を呼び出しているのではなく、plus1のポインタを代入している点に注意します。  
これは、char\*とchar[]の関係に似ていて、実際にplus1と書くだけで関数の(機械語列)先頭へのポインタが得られます。  
※ `char* buf`や`char buf[64]`と定義した際、bufと書けばどちらの場合でも配列先頭へのポインタを得られます。

### ■ signal(2)の実装上の問題
signal(2)は使わないようにしましょう。

### ■
